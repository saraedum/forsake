r"""
Helpers to set up client and server processes for testing

Tests should implement from :class:`ClientServer` to spawn clients and server
processes on an autogenerated socket.
"""
# ********************************************************************
#  This file is part of forsake
#
#        Copyright (C) 2023 Julian RÃ¼th
#
#  forsake is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  forsake is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with forsake. If not, see <https://www.gnu.org/licenses/>.
# ********************************************************************


import contextlib
from tempfile import TemporaryDirectory
from multiprocessing import Process

import os.path

import pytest

import forsake.server
import forsake.client


class ClientServer:
    r"""
    Base class to conveniently start a client and a server as subprocesses that
    talk to each other for testing.
    """
    @pytest.fixture(autouse=True)
    def socket(self):
        r"""
        Return a randomly and securely created socket name that gets cleaned up
        when the tests are completed.
        """

        with TemporaryDirectory() as sockdir:
            yield os.path.join(sockdir, "socket")

    @contextlib.contextmanager
    def spawn_server(self, socket, server=forsake.server.Server):
        r"""
        Spawn ``server`` as a subprocess of the current process.

        Returns the process whose ``.server`` contains the actual server object.
        """
        server = server(socket)
        # We have to set daemon=False so that the server can fork child processes.
        process = Process(target=server.start, daemon=False)
        process.server = server
        process.start()
        yield process
        process.kill()
        process.join()
        assert process.exitcode == -9, f"{process.exitcode} != -9"

    @contextlib.contextmanager
    def spawn_client(self, socket, client=forsake.client.Client, exitcode=0):
        r"""
        Spawn ``client`` as a subprocess of the current process.

        Returns the process whose ``.client`` contains the actual client object.
        """
        client = client(socket)
        process = Process(target=client.start, daemon=True)
        process.client = client
        process.start()
        yield process
        process.join()
        assert process.exitcode == exitcode, f"{process.exitcode} != {exitcode}"
